（一）Elasticsearch在搜索过程中存在以下几个问题：
　　（1）返回数据量问题
　　　　如果数据分散在默认的5个分片上，ES会向5个分片同时发出请求，每个分片都返回10条数据，最终会返回总数据为：5 * 10 = 50条数据，远远大于用户请求。

　　（2）返回数据排名问题
　　　　每个分片计算符合条件的前10条数据都是基于自己分片的数据进行打分计算的。计算分值（score）使用的词频和文档频率等信息都是基于自己分片的数据进行的，而ES进行整体排名是基于排名是基于每个分片计算后的分值进行排序的（打分依据就不一致，最终对这些数据统一排名的时候就不准确了）

（二）Elasticsearch在搜索问题的解决思路

　　（1）返回数据数量问题
　　　　第一步：先从每个分片汇总查询的数据id，进行排名，取前10条数据
　　　　第二步：根据这10条数据id，到不同分片获取数据
　　（2）返回数据排名问题
　　　　将各个分片打分标准统一

（三）Elasticsearch的搜索类型（SearchType类型）

1、 query and fetch
　　向索引的所有分片 （ shard）都发出查询请求， 各分片返回的时候把元素文档 （ document）和计算后的排名信息一起返回。
　　这种搜索方式是最快的。 因为相比下面的几种搜索方式， 这种查询方法只需要去 shard查询一次。 但是各个 shard 返回的结果的数量之和可能是用户要求的 size 的 n 倍。
　　优点：这种搜索方式是最快的。因为相比后面的几种es的搜索方式，这种查询方法只需要去shard查询一次。
　　缺点：返回的数据量不准确， 可能返回(N*分片数量)的数据并且数据排名也不准确，同时各个shard返回的结果的数量之和可能是用户要求的size的n倍。
　
2、 query then fetch（ es 默认的搜索方式）
　　如果你搜索时， 没有指定搜索方式， 就是使用的这种搜索方式。 这种搜索方式， 大概分两个步骤：
　　第一步， 先向所有的 shard 发出请求， 各分片只返回文档 id(注意， 不包括文档 document)和排名相关的信息(也就是文档对应的分值)， 然后按照各分片返回的文档的分数进行重新排序和排名， 取前 size 个文档。
　　第二步， 根据文档 id 去相关的 shard 取 document。 这种方式返回的 document 数量与用户要求的大小是相等的。
　　优点：
　　　　返回的数据量是准确的。
　　缺点：
　　　　性能一般，并且数据排名不准确。

3、 DFS query and fetch
　　这种方式比第一种方式多了一个 DFS 步骤，有这一步，可以更精确控制搜索打分和排名。也就是在进行查询之前， 先对所有分片发送请求， 把所有分片中的词频和文档频率等打分依据全部汇总到一块， 再执行后面的操作、
　　优点：
　　　　数据排名准确
　　缺点：
　　　　性能一般
　　　　返回的数据量不准确， 可能返回(N*分片数量)的数据

4、 DFS query then fetch
　　比第 2 种方式多了一个 DFS 步骤。
　　也就是在进行查询之前， 先对所有分片发送请求， 把所有分片中的词频和文档频率等打分依据全部汇总到一块， 再执行后面的操作、

　　优点：
　　　　返回的数据量是准确的
　　　　数据排名准确
　　缺点：
　　　　性能最差【 这个最差只是表示在这四种查询方式中性能最慢， 也不至于不能忍受，如果对查询性能要求不是非常高， 而对查询准确度要求比较高的时候可以考虑这个】

　　DFS 是一个什么样的过程？
　　从 es 的官方网站我们可以发现， DFS 其实就是在进行真正的查询之前， 先把各个分片的词频率和文档频率收集一下， 然后进行词搜索的时候， 各分片依据全局的词频率和文档频率进行搜索和排名。 显然如果使用 DFS_QUERY_THEN_FETCH 这种查询方式， 效率是最低的，因为一个搜索， 可能要请求 3 次分片。 但， 使用 DFS 方法， 搜索精度是最高的。

　　总结一下， 从性能考虑 QUERY_AND_FETCH 是最快的， DFS_QUERY_THEN_FETCH 是最慢的。从搜索的准确度来说， DFS 要比非 DFS 的准确度更高。